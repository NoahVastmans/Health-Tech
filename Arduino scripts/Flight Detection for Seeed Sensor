#include <LSM6DS3.h> //needs minor modification
#include <MadgwickAHRS.h> //needs minor modifications
#include <Wire.h>

#undef DEG_TO_RAD
#define DEG_TO_RAD 0.01745329251994329576923690768489

LSM6DS3 IMU(I2C_MODE, 0x6A);
Madgwick filter;

const int soundTriggerPin = 7; //EDIT---------------------------------------------------


enum FlightStage {
    PRE_FLIGHT,
    THROWING,
    IN_AIR,
    APEX,
    CATCH
};

FlightStage currentStage = PRE_FLIGHT;

float ax, ay, az;
float gx, gy, gz;
float verticalVelocity = 0.0;
float prevVerticalVelocity = 0.0;
float timeStep = 0.0;
unsigned long previousTime = 0;

float filteredAz = 0.0;
const float alpha = 0.5; // Low-pass filter coefficient


const float THROWING_ACCEL_THRESHOLD = 10.0;
const float CATCH_ACCEL_THRESHOLD = 15.0;
const float GRAVITY_THRESHOLD = 2.0;

int config_free_fall_detect(void) {
    uint8_t error = 0;
    uint8_t dataToWrite = 0;

    dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_200Hz;
    dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_2g;
    dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_416Hz;
    error += IMU.writeRegister(LSM6DS3_ACC_GYRO_CTRL1_XL, dataToWrite);
    error += IMU.writeRegister(LSM6DS3_ACC_GYRO_FREE_FALL, 0x33);
    error += IMU.writeRegister(LSM6DS3_ACC_GYRO_MD1_CFG, 0x10);

    return error;
}

void setup() {
    Serial.begin(9600);
    while (!Serial);

    if (!IMU.begin()) {
        Serial.println("Failed to initialize IMU!");
        while (1);
    }

    if (0 != config_free_fall_detect()) {
        Serial.println("Fail to configure free-fall detection!");
        while (1);
    } else {
        Serial.println("Success to configure IMU!");
    }

    filter.begin(100.0);
    Serial.println("Madgwick filter initialized.");
    Serial.println("System ready. Stage: PRE-FLIGHT");

    previousTime = millis();

    pinMode(soundTriggerPin, OUTPUT);
}

void loop() {
    digitalWrite(soundTriggerPin, LOW); // Ensure it's off initially
    readSensors();
    updateFilter();
    computeTimeStep();
    float verticalAccel = getVerticalAcceleration();
    filteredAz = alpha * verticalAccel + (1 - alpha) * filteredAz;

    bool freeFallDetected = checkFreeFallInterrupt();
    handleFlightStage(filteredAz, freeFallDetected);
}

void readSensors() {
    ax = IMU.readFloatAccelX();
    ay = IMU.readFloatAccelY();
    az = IMU.readFloatAccelZ();

    gx = IMU.readFloatGyroX() * DEG_TO_RAD;
    gy = IMU.readFloatGyroY() * DEG_TO_RAD;
    gz = IMU.readFloatGyroZ() * DEG_TO_RAD;
}

void updateFilter() {
    filter.updateIMU(gx, gy, gz, ax, ay, az);
}

void computeTimeStep() {
    unsigned long currentTime = millis();
    timeStep = (currentTime - previousTime) / 1000.0;
    previousTime = currentTime;
}

float getVerticalAcceleration() {
    float qw, qx, qy, qz;
    filter.getQuaternion(&qw, &qx, &qy, &qz);

    // Rotate acceleration vector into global frame using quaternion rotation
    float gAx = ax * (1 - 2 * (qy * qy + qz * qz)) + ay * (2 * (qx * qy - qw * qz)) + az * (2 * (qx * qz + qw * qy));
    float gAy = ax * (2 * (qx * qy + qw * qz)) + ay * (1 - 2 * (qx * qx + qz * qz)) + az * (2 * (qy * qz - qw * qx));
    float gAz = ax * (2 * (qx * qz - qw * qy)) + ay * (2 * (qy * qz + qw * qx)) + az * (1 - 2 * (qx * qx + qy * qy));

    return gAz;
}

bool checkFreeFallInterrupt() {
    uint8_t readDataByte = 0;
    IMU.readRegister(&readDataByte, LSM6DS3_ACC_GYRO_WAKE_UP_SRC);
    return (readDataByte & 0x20);
}

void handleFlightStage(float verticalAccel, bool freeFallDetected) {
    switch (currentStage) {
        case PRE_FLIGHT:
            if (abs(verticalAccel) > THROWING_ACCEL_THRESHOLD) {
                currentStage = THROWING;
                Serial.println("Stage: THROWING");
                verticalVelocity = 0.0;
            }
            break;

        case THROWING:
            if (freeFallDetected || abs(verticalAccel - 9.81) < GRAVITY_THRESHOLD) {
                currentStage = IN_AIR;
                Serial.println("Stage: IN-AIR");
            }
            break;

        case IN_AIR:
            prevVerticalVelocity = verticalVelocity;
            verticalVelocity += (verticalAccel - 9.81) * timeStep;

            if (prevVerticalVelocity > 0 && verticalVelocity <= 0) {
                currentStage = APEX;
                Serial.println("Stage: APEX");
            }
            break;

        case APEX:
            if (abs(verticalAccel) > CATCH_ACCEL_THRESHOLD) {
                currentStage = CATCH;
                Serial.println("Stage: CATCH");
            } else {
                // Trigger sound at apex
                Serial.println("Triggering sound at APEX");
                digitalWrite(soundTriggerPin, HIGH);
                delay(100); // Sound duration (adjust as needed)
                digitalWrite(soundTriggerPin, LOW);
            }
            break;
        case CATCH:
            Serial.println("Flight sequence complete. Resetting...");
            delay(2000);
            currentStage = PRE_FLIGHT;
            break;
    }
}
